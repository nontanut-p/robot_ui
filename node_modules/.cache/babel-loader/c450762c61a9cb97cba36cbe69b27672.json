{"ast":null,"code":"var _regeneratorRuntime = require(\"/home/pat/robot_ui/node_modules/@babel/runtime/regenerator\");\n\nvar _asyncToGenerator = require(\"/home/pat/robot_ui/node_modules/@babel/runtime/helpers/asyncToGenerator\");\n\nvar _classCallCheck = require(\"/home/pat/robot_ui/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"/home/pat/robot_ui/node_modules/@babel/runtime/helpers/createClass\");\n\nvar _inherits = require(\"/home/pat/robot_ui/node_modules/@babel/runtime/helpers/inherits\");\n\nvar _createSuper = require(\"/home/pat/robot_ui/node_modules/@babel/runtime/helpers/createSuper\");\n\nvar qs = require(\"querystring\");\n\nvar parse = require(\"url\").parse;\n\nvar base64id = require(\"base64id\");\n\nvar transports = require(\"./transports\");\n\nvar EventEmitter = require(\"events\").EventEmitter;\n\nvar Socket = require(\"./socket\");\n\nvar debug = require(\"debug\")(\"engine\");\n\nvar cookieMod = require(\"cookie\");\n\nvar DEFAULT_WS_ENGINE = require(\"ws\").Server;\n\nvar Server = /*#__PURE__*/function (_EventEmitter) {\n  \"use strict\";\n\n  _inherits(Server, _EventEmitter);\n\n  var _super = _createSuper(Server);\n\n  /**\n   * Server constructor.\n   *\n   * @param {Object} options\n   * @api public\n   */\n  function Server() {\n    var _this;\n\n    var opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n    _classCallCheck(this, Server);\n\n    _this = _super.call(this);\n    _this.clients = {};\n    _this.clientsCount = 0;\n    _this.opts = Object.assign({\n      wsEngine: DEFAULT_WS_ENGINE,\n      pingTimeout: 20000,\n      pingInterval: 25000,\n      upgradeTimeout: 10000,\n      maxHttpBufferSize: 1e6,\n      transports: Object.keys(transports),\n      allowUpgrades: true,\n      httpCompression: {\n        threshold: 1024\n      },\n      cors: false,\n      allowEIO3: false\n    }, opts);\n\n    if (opts.cookie) {\n      _this.opts.cookie = Object.assign({\n        name: \"io\",\n        path: \"/\",\n        httpOnly: opts.cookie.path !== false,\n        sameSite: \"lax\"\n      }, opts.cookie);\n    }\n\n    if (_this.opts.cors) {\n      _this.corsMiddleware = require(\"cors\")(_this.opts.cors);\n    }\n\n    if (opts.perMessageDeflate) {\n      _this.opts.perMessageDeflate = Object.assign({\n        threshold: 1024\n      }, opts.perMessageDeflate);\n    }\n\n    _this.init();\n\n    return _this;\n  }\n  /**\n   * Initialize websocket server\n   *\n   * @api private\n   */\n\n\n  _createClass(Server, [{\n    key: \"init\",\n    value: function init() {\n      var _this2 = this;\n\n      if (!~this.opts.transports.indexOf(\"websocket\")) return;\n      if (this.ws) this.ws.close();\n      this.ws = new this.opts.wsEngine({\n        noServer: true,\n        clientTracking: false,\n        perMessageDeflate: this.opts.perMessageDeflate,\n        maxPayload: this.opts.maxHttpBufferSize\n      });\n\n      if (typeof this.ws.on === \"function\") {\n        this.ws.on(\"headers\", function (headersArray, req) {\n          // note: 'ws' uses an array of headers, while Engine.IO uses an object (response.writeHead() accepts both formats)\n          // we could also try to parse the array and then sync the values, but that will be error-prone\n          var additionalHeaders = {};\n          var isInitialRequest = !req._query.sid;\n\n          if (isInitialRequest) {\n            _this2.emit(\"initial_headers\", additionalHeaders, req);\n          }\n\n          _this2.emit(\"headers\", additionalHeaders, req);\n\n          Object.keys(additionalHeaders).forEach(function (key) {\n            headersArray.push(\"\".concat(key, \": \").concat(additionalHeaders[key]));\n          });\n        });\n      }\n    }\n    /**\n     * Returns a list of available transports for upgrade given a certain transport.\n     *\n     * @return {Array}\n     * @api public\n     */\n\n  }, {\n    key: \"upgrades\",\n    value: function upgrades(transport) {\n      if (!this.opts.allowUpgrades) return [];\n      return transports[transport].upgradesTo || [];\n    }\n    /**\n     * Verifies a request.\n     *\n     * @param {http.IncomingMessage}\n     * @return {Boolean} whether the request is valid\n     * @api private\n     */\n\n  }, {\n    key: \"verify\",\n    value: function verify(req, upgrade, fn) {\n      // transport check\n      var transport = req._query.transport;\n\n      if (!~this.opts.transports.indexOf(transport)) {\n        debug('unknown transport \"%s\"', transport);\n        return fn(Server.errors.UNKNOWN_TRANSPORT, {\n          transport: transport\n        });\n      } // 'Origin' header check\n\n\n      var isOriginInvalid = checkInvalidHeaderChar(req.headers.origin);\n\n      if (isOriginInvalid) {\n        var origin = req.headers.origin;\n        req.headers.origin = null;\n        debug(\"origin header invalid\");\n        return fn(Server.errors.BAD_REQUEST, {\n          name: \"INVALID_ORIGIN\",\n          origin: origin\n        });\n      } // sid check\n\n\n      var sid = req._query.sid;\n\n      if (sid) {\n        if (!this.clients.hasOwnProperty(sid)) {\n          debug('unknown sid \"%s\"', sid);\n          return fn(Server.errors.UNKNOWN_SID, {\n            sid: sid\n          });\n        }\n\n        var previousTransport = this.clients[sid].transport.name;\n\n        if (!upgrade && previousTransport !== transport) {\n          debug(\"bad request: unexpected transport without upgrade\");\n          return fn(Server.errors.BAD_REQUEST, {\n            name: \"TRANSPORT_MISMATCH\",\n            transport: transport,\n            previousTransport: previousTransport\n          });\n        }\n      } else {\n        // handshake is GET only\n        if (\"GET\" !== req.method) {\n          return fn(Server.errors.BAD_HANDSHAKE_METHOD, {\n            method: req.method\n          });\n        }\n\n        if (!this.opts.allowRequest) return fn();\n        return this.opts.allowRequest(req, function (message, success) {\n          if (!success) {\n            return fn(Server.errors.FORBIDDEN, {\n              message: message\n            });\n          }\n\n          fn();\n        });\n      }\n\n      fn();\n    }\n    /**\n     * Prepares a request by processing the query string.\n     *\n     * @api private\n     */\n\n  }, {\n    key: \"prepare\",\n    value: function prepare(req) {\n      // try to leverage pre-existing `req._query` (e.g: from connect)\n      if (!req._query) {\n        req._query = ~req.url.indexOf(\"?\") ? qs.parse(parse(req.url).query) : {};\n      }\n    }\n    /**\n     * Closes all clients.\n     *\n     * @api public\n     */\n\n  }, {\n    key: \"close\",\n    value: function close() {\n      debug(\"closing all open clients\");\n\n      for (var i in this.clients) {\n        if (this.clients.hasOwnProperty(i)) {\n          this.clients[i].close(true);\n        }\n      }\n\n      if (this.ws) {\n        debug(\"closing webSocketServer\");\n        this.ws.close(); // don't delete this.ws because it can be used again if the http server starts listening again\n      }\n\n      return this;\n    }\n    /**\n     * Handles an Engine.IO HTTP request.\n     *\n     * @param {http.IncomingMessage} request\n     * @param {http.ServerResponse|http.OutgoingMessage} response\n     * @api public\n     */\n\n  }, {\n    key: \"handleRequest\",\n    value: function handleRequest(req, res) {\n      var _this3 = this;\n\n      debug('handling \"%s\" http request \"%s\"', req.method, req.url);\n      this.prepare(req);\n      req.res = res;\n\n      var callback = function callback(errorCode, errorContext) {\n        if (errorCode !== undefined) {\n          _this3.emit(\"connection_error\", {\n            req: req,\n            code: errorCode,\n            message: Server.errorMessages[errorCode],\n            context: errorContext\n          });\n\n          abortRequest(res, errorCode, errorContext);\n          return;\n        }\n\n        if (req._query.sid) {\n          debug(\"setting new request for existing client\");\n\n          _this3.clients[req._query.sid].transport.onRequest(req);\n        } else {\n          var closeConnection = function closeConnection(errorCode, errorContext) {\n            return abortRequest(res, errorCode, errorContext);\n          };\n\n          _this3.handshake(req._query.transport, req, closeConnection);\n        }\n      };\n\n      if (this.corsMiddleware) {\n        this.corsMiddleware.call(null, req, res, function () {\n          _this3.verify(req, false, callback);\n        });\n      } else {\n        this.verify(req, false, callback);\n      }\n    }\n    /**\n     * generate a socket id.\n     * Overwrite this method to generate your custom socket id\n     *\n     * @param {Object} request object\n     * @api public\n     */\n\n  }, {\n    key: \"generateId\",\n    value: function generateId(req) {\n      return base64id.generateId();\n    }\n    /**\n     * Handshakes a new client.\n     *\n     * @param {String} transport name\n     * @param {Object} request object\n     * @param {Function} closeConnection\n     *\n     * @api private\n     */\n\n  }, {\n    key: \"handshake\",\n    value: function () {\n      var _handshake = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee(transportName, req, closeConnection) {\n        var _this4 = this;\n\n        var protocol, id, transport, socket;\n        return _regeneratorRuntime.wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                protocol = req._query.EIO === \"4\" ? 4 : 3; // 3rd revision by default\n\n                if (!(protocol === 3 && !this.opts.allowEIO3)) {\n                  _context.next = 6;\n                  break;\n                }\n\n                debug(\"unsupported protocol version\");\n                this.emit(\"connection_error\", {\n                  req: req,\n                  code: Server.errors.UNSUPPORTED_PROTOCOL_VERSION,\n                  message: Server.errorMessages[Server.errors.UNSUPPORTED_PROTOCOL_VERSION],\n                  context: {\n                    protocol: protocol\n                  }\n                });\n                closeConnection(Server.errors.UNSUPPORTED_PROTOCOL_VERSION);\n                return _context.abrupt(\"return\");\n\n              case 6:\n                _context.prev = 6;\n                _context.next = 9;\n                return this.generateId(req);\n\n              case 9:\n                id = _context.sent;\n                _context.next = 18;\n                break;\n\n              case 12:\n                _context.prev = 12;\n                _context.t0 = _context[\"catch\"](6);\n                debug(\"error while generating an id\");\n                this.emit(\"connection_error\", {\n                  req: req,\n                  code: Server.errors.BAD_REQUEST,\n                  message: Server.errorMessages[Server.errors.BAD_REQUEST],\n                  context: {\n                    name: \"ID_GENERATION_ERROR\",\n                    error: _context.t0\n                  }\n                });\n                closeConnection(Server.errors.BAD_REQUEST);\n                return _context.abrupt(\"return\");\n\n              case 18:\n                debug('handshaking client \"%s\"', id);\n                _context.prev = 19;\n                transport = new transports[transportName](req);\n\n                if (\"polling\" === transportName) {\n                  transport.maxHttpBufferSize = this.opts.maxHttpBufferSize;\n                  transport.httpCompression = this.opts.httpCompression;\n                } else if (\"websocket\" === transportName) {\n                  transport.perMessageDeflate = this.opts.perMessageDeflate;\n                }\n\n                if (req._query && req._query.b64) {\n                  transport.supportsBinary = false;\n                } else {\n                  transport.supportsBinary = true;\n                }\n\n                _context.next = 31;\n                break;\n\n              case 25:\n                _context.prev = 25;\n                _context.t1 = _context[\"catch\"](19);\n                debug('error handshaking to transport \"%s\"', transportName);\n                this.emit(\"connection_error\", {\n                  req: req,\n                  code: Server.errors.BAD_REQUEST,\n                  message: Server.errorMessages[Server.errors.BAD_REQUEST],\n                  context: {\n                    name: \"TRANSPORT_HANDSHAKE_ERROR\",\n                    error: _context.t1\n                  }\n                });\n                closeConnection(Server.errors.BAD_REQUEST);\n                return _context.abrupt(\"return\");\n\n              case 31:\n                socket = new Socket(id, this, transport, req, protocol);\n                transport.on(\"headers\", function (headers, req) {\n                  var isInitialRequest = !req._query.sid;\n\n                  if (isInitialRequest) {\n                    if (_this4.opts.cookie) {\n                      headers[\"Set-Cookie\"] = [cookieMod.serialize(_this4.opts.cookie.name, id, _this4.opts.cookie)];\n                    }\n\n                    _this4.emit(\"initial_headers\", headers, req);\n                  }\n\n                  _this4.emit(\"headers\", headers, req);\n                });\n                transport.onRequest(req);\n                this.clients[id] = socket;\n                this.clientsCount++;\n                socket.once(\"close\", function () {\n                  delete _this4.clients[id];\n                  _this4.clientsCount--;\n                });\n                this.emit(\"connection\", socket);\n\n              case 38:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        }, _callee, this, [[6, 12], [19, 25]]);\n      }));\n\n      function handshake(_x, _x2, _x3) {\n        return _handshake.apply(this, arguments);\n      }\n\n      return handshake;\n    }()\n    /**\n     * Handles an Engine.IO HTTP Upgrade.\n     *\n     * @api public\n     */\n\n  }, {\n    key: \"handleUpgrade\",\n    value: function handleUpgrade(req, socket, upgradeHead) {\n      var _this5 = this;\n\n      this.prepare(req);\n      this.verify(req, true, function (errorCode, errorContext) {\n        if (errorCode) {\n          _this5.emit(\"connection_error\", {\n            req: req,\n            code: errorCode,\n            message: Server.errorMessages[errorCode],\n            context: errorContext\n          });\n\n          abortUpgrade(socket, errorCode, errorContext);\n          return;\n        }\n\n        var head = Buffer.from(upgradeHead); // eslint-disable-line node/no-deprecated-api\n\n        upgradeHead = null; // delegate to ws\n\n        _this5.ws.handleUpgrade(req, socket, head, function (websocket) {\n          _this5.onWebSocket(req, socket, websocket);\n        });\n      });\n    }\n    /**\n     * Called upon a ws.io connection.\n     *\n     * @param {ws.Socket} websocket\n     * @api private\n     */\n\n  }, {\n    key: \"onWebSocket\",\n    value: function onWebSocket(req, socket, websocket) {\n      websocket.on(\"error\", onUpgradeError);\n\n      if (transports[req._query.transport] !== undefined && !transports[req._query.transport].prototype.handlesUpgrades) {\n        debug(\"transport doesnt handle upgraded requests\");\n        websocket.close();\n        return;\n      } // get client id\n\n\n      var id = req._query.sid; // keep a reference to the ws.Socket\n\n      req.websocket = websocket;\n\n      if (id) {\n        var client = this.clients[id];\n\n        if (!client) {\n          debug(\"upgrade attempt for closed client\");\n          websocket.close();\n        } else if (client.upgrading) {\n          debug(\"transport has already been trying to upgrade\");\n          websocket.close();\n        } else if (client.upgraded) {\n          debug(\"transport had already been upgraded\");\n          websocket.close();\n        } else {\n          debug(\"upgrading existing transport\"); // transport error handling takes over\n\n          websocket.removeListener(\"error\", onUpgradeError);\n          var transport = new transports[req._query.transport](req);\n\n          if (req._query && req._query.b64) {\n            transport.supportsBinary = false;\n          } else {\n            transport.supportsBinary = true;\n          }\n\n          transport.perMessageDeflate = this.perMessageDeflate;\n          client.maybeUpgrade(transport);\n        }\n      } else {\n        // transport error handling takes over\n        websocket.removeListener(\"error\", onUpgradeError);\n\n        var closeConnection = function closeConnection(errorCode, errorContext) {\n          return abortUpgrade(socket, errorCode, errorContext);\n        };\n\n        this.handshake(req._query.transport, req, closeConnection);\n      }\n\n      function onUpgradeError() {\n        debug(\"websocket error before upgrade\"); // websocket.close() not needed\n      }\n    }\n    /**\n     * Captures upgrade requests for a http.Server.\n     *\n     * @param {http.Server} server\n     * @param {Object} options\n     * @api public\n     */\n\n  }, {\n    key: \"attach\",\n    value: function attach(server) {\n      var _this6 = this;\n\n      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n      var path = (options.path || \"/engine.io\").replace(/\\/$/, \"\");\n      var destroyUpgradeTimeout = options.destroyUpgradeTimeout || 1000; // normalize path\n\n      path += \"/\";\n\n      function check(req) {\n        return path === req.url.substr(0, path.length);\n      } // cache and clean up listeners\n\n\n      var listeners = server.listeners(\"request\").slice(0);\n      server.removeAllListeners(\"request\");\n      server.on(\"close\", this.close.bind(this));\n      server.on(\"listening\", this.init.bind(this)); // add request handler\n\n      server.on(\"request\", function (req, res) {\n        if (check(req)) {\n          debug('intercepting request for path \"%s\"', path);\n\n          _this6.handleRequest(req, res);\n        } else {\n          var i = 0;\n          var l = listeners.length;\n\n          for (; i < l; i++) {\n            listeners[i].call(server, req, res);\n          }\n        }\n      });\n\n      if (~this.opts.transports.indexOf(\"websocket\")) {\n        server.on(\"upgrade\", function (req, socket, head) {\n          if (check(req)) {\n            _this6.handleUpgrade(req, socket, head);\n          } else if (false !== options.destroyUpgrade) {\n            // default node behavior is to disconnect when no handlers\n            // but by adding a handler, we prevent that\n            // and if no eio thing handles the upgrade\n            // then the socket needs to die!\n            setTimeout(function () {\n              if (socket.writable && socket.bytesWritten <= 0) {\n                return socket.end();\n              }\n            }, destroyUpgradeTimeout);\n          }\n        });\n      }\n    }\n  }]);\n\n  return Server;\n}(EventEmitter);\n/**\n * Protocol errors mappings.\n */\n\n\nServer.errors = {\n  UNKNOWN_TRANSPORT: 0,\n  UNKNOWN_SID: 1,\n  BAD_HANDSHAKE_METHOD: 2,\n  BAD_REQUEST: 3,\n  FORBIDDEN: 4,\n  UNSUPPORTED_PROTOCOL_VERSION: 5\n};\nServer.errorMessages = {\n  0: \"Transport unknown\",\n  1: \"Session ID unknown\",\n  2: \"Bad handshake method\",\n  3: \"Bad request\",\n  4: \"Forbidden\",\n  5: \"Unsupported protocol version\"\n};\n/**\n * Close the HTTP long-polling request\n *\n * @param res - the response object\n * @param errorCode - the error code\n * @param errorContext - additional error context\n *\n * @api private\n */\n\nfunction abortRequest(res, errorCode, errorContext) {\n  var statusCode = errorCode === Server.errors.FORBIDDEN ? 403 : 400;\n  var message = errorContext && errorContext.message ? errorContext.message : Server.errorMessages[errorCode];\n  res.writeHead(statusCode, {\n    \"Content-Type\": \"application/json\"\n  });\n  res.end(JSON.stringify({\n    code: errorCode,\n    message: message\n  }));\n}\n/**\n * Close the WebSocket connection\n *\n * @param {net.Socket} socket\n * @param {string} errorCode - the error code\n * @param {object} errorContext - additional error context\n *\n * @api private\n */\n\n\nfunction abortUpgrade(socket, errorCode) {\n  var errorContext = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  socket.on(\"error\", function () {\n    debug(\"ignoring error from closed connection\");\n  });\n\n  if (socket.writable) {\n    var message = errorContext.message || Server.errorMessages[errorCode];\n    var length = Buffer.byteLength(message);\n    socket.write(\"HTTP/1.1 400 Bad Request\\r\\n\" + \"Connection: close\\r\\n\" + \"Content-type: text/html\\r\\n\" + \"Content-Length: \" + length + \"\\r\\n\" + \"\\r\\n\" + message);\n  }\n\n  socket.destroy();\n}\n\nmodule.exports = Server;\n/* eslint-disable */\n\n/**\n * From https://github.com/nodejs/node/blob/v8.4.0/lib/_http_common.js#L303-L354\n *\n * True if val contains an invalid field-vchar\n *  field-value    = *( field-content / obs-fold )\n *  field-content  = field-vchar [ 1*( SP / HTAB ) field-vchar ]\n *  field-vchar    = VCHAR / obs-text\n *\n * checkInvalidHeaderChar() is currently designed to be inlinable by v8,\n * so take care when making changes to the implementation so that the source\n * code size does not exceed v8's default max_inlined_source_size setting.\n **/\n// prettier-ignore\n\nvar validHdrChars = [0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, // 0 - 15\n0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, // 16 - 31\n1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, // 32 - 47\n1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, // 48 - 63\n1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, // 64 - 79\n1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, // 80 - 95\n1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, // 96 - 111\n1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, // 112 - 127\n1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, // 128 ...\n1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1 // ... 255\n];\n\nfunction checkInvalidHeaderChar(val) {\n  val += \"\";\n  if (val.length < 1) return false;\n\n  if (!validHdrChars[val.charCodeAt(0)]) {\n    debug('invalid header, index 0, char \"%s\"', val.charCodeAt(0));\n    return true;\n  }\n\n  if (val.length < 2) return false;\n\n  if (!validHdrChars[val.charCodeAt(1)]) {\n    debug('invalid header, index 1, char \"%s\"', val.charCodeAt(1));\n    return true;\n  }\n\n  if (val.length < 3) return false;\n\n  if (!validHdrChars[val.charCodeAt(2)]) {\n    debug('invalid header, index 2, char \"%s\"', val.charCodeAt(2));\n    return true;\n  }\n\n  if (val.length < 4) return false;\n\n  if (!validHdrChars[val.charCodeAt(3)]) {\n    debug('invalid header, index 3, char \"%s\"', val.charCodeAt(3));\n    return true;\n  }\n\n  for (var i = 4; i < val.length; ++i) {\n    if (!validHdrChars[val.charCodeAt(i)]) {\n      debug('invalid header, index \"%i\", char \"%s\"', i, val.charCodeAt(i));\n      return true;\n    }\n  }\n\n  return false;\n}","map":{"version":3,"sources":["/home/pat/robot_ui/node_modules/engine.io/lib/server.js"],"names":["qs","require","parse","base64id","transports","EventEmitter","Socket","debug","cookieMod","DEFAULT_WS_ENGINE","Server","opts","clients","clientsCount","Object","assign","wsEngine","pingTimeout","pingInterval","upgradeTimeout","maxHttpBufferSize","keys","allowUpgrades","httpCompression","threshold","cors","allowEIO3","cookie","name","path","httpOnly","sameSite","corsMiddleware","perMessageDeflate","init","indexOf","ws","close","noServer","clientTracking","maxPayload","on","headersArray","req","additionalHeaders","isInitialRequest","_query","sid","emit","forEach","key","push","transport","upgradesTo","upgrade","fn","errors","UNKNOWN_TRANSPORT","isOriginInvalid","checkInvalidHeaderChar","headers","origin","BAD_REQUEST","hasOwnProperty","UNKNOWN_SID","previousTransport","method","BAD_HANDSHAKE_METHOD","allowRequest","message","success","FORBIDDEN","url","query","i","res","prepare","callback","errorCode","errorContext","undefined","code","errorMessages","context","abortRequest","onRequest","closeConnection","handshake","call","verify","generateId","transportName","protocol","EIO","UNSUPPORTED_PROTOCOL_VERSION","id","error","b64","supportsBinary","socket","serialize","once","upgradeHead","abortUpgrade","head","Buffer","from","handleUpgrade","websocket","onWebSocket","onUpgradeError","prototype","handlesUpgrades","client","upgrading","upgraded","removeListener","maybeUpgrade","server","options","replace","destroyUpgradeTimeout","check","substr","length","listeners","slice","removeAllListeners","bind","handleRequest","l","destroyUpgrade","setTimeout","writable","bytesWritten","end","statusCode","writeHead","JSON","stringify","byteLength","write","destroy","module","exports","validHdrChars","val","charCodeAt"],"mappings":"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","sourcesContent":["const qs = require(\"querystring\");\nconst parse = require(\"url\").parse;\nconst base64id = require(\"base64id\");\nconst transports = require(\"./transports\");\nconst EventEmitter = require(\"events\").EventEmitter;\nconst Socket = require(\"./socket\");\nconst debug = require(\"debug\")(\"engine\");\nconst cookieMod = require(\"cookie\");\n\nconst DEFAULT_WS_ENGINE = require(\"ws\").Server;\n\nclass Server extends EventEmitter {\n  /**\n   * Server constructor.\n   *\n   * @param {Object} options\n   * @api public\n   */\n  constructor(opts = {}) {\n    super();\n\n    this.clients = {};\n    this.clientsCount = 0;\n\n    this.opts = Object.assign(\n      {\n        wsEngine: DEFAULT_WS_ENGINE,\n        pingTimeout: 20000,\n        pingInterval: 25000,\n        upgradeTimeout: 10000,\n        maxHttpBufferSize: 1e6,\n        transports: Object.keys(transports),\n        allowUpgrades: true,\n        httpCompression: {\n          threshold: 1024\n        },\n        cors: false,\n        allowEIO3: false\n      },\n      opts\n    );\n\n    if (opts.cookie) {\n      this.opts.cookie = Object.assign(\n        {\n          name: \"io\",\n          path: \"/\",\n          httpOnly: opts.cookie.path !== false,\n          sameSite: \"lax\"\n        },\n        opts.cookie\n      );\n    }\n\n    if (this.opts.cors) {\n      this.corsMiddleware = require(\"cors\")(this.opts.cors);\n    }\n\n    if (opts.perMessageDeflate) {\n      this.opts.perMessageDeflate = Object.assign(\n        {\n          threshold: 1024\n        },\n        opts.perMessageDeflate\n      );\n    }\n\n    this.init();\n  }\n\n  /**\n   * Initialize websocket server\n   *\n   * @api private\n   */\n  init() {\n    if (!~this.opts.transports.indexOf(\"websocket\")) return;\n\n    if (this.ws) this.ws.close();\n\n    this.ws = new this.opts.wsEngine({\n      noServer: true,\n      clientTracking: false,\n      perMessageDeflate: this.opts.perMessageDeflate,\n      maxPayload: this.opts.maxHttpBufferSize\n    });\n\n    if (typeof this.ws.on === \"function\") {\n      this.ws.on(\"headers\", (headersArray, req) => {\n        // note: 'ws' uses an array of headers, while Engine.IO uses an object (response.writeHead() accepts both formats)\n        // we could also try to parse the array and then sync the values, but that will be error-prone\n        const additionalHeaders = {};\n\n        const isInitialRequest = !req._query.sid;\n        if (isInitialRequest) {\n          this.emit(\"initial_headers\", additionalHeaders, req);\n        }\n\n        this.emit(\"headers\", additionalHeaders, req);\n\n        Object.keys(additionalHeaders).forEach(key => {\n          headersArray.push(`${key}: ${additionalHeaders[key]}`);\n        });\n      });\n    }\n  }\n\n  /**\n   * Returns a list of available transports for upgrade given a certain transport.\n   *\n   * @return {Array}\n   * @api public\n   */\n  upgrades(transport) {\n    if (!this.opts.allowUpgrades) return [];\n    return transports[transport].upgradesTo || [];\n  }\n\n  /**\n   * Verifies a request.\n   *\n   * @param {http.IncomingMessage}\n   * @return {Boolean} whether the request is valid\n   * @api private\n   */\n  verify(req, upgrade, fn) {\n    // transport check\n    const transport = req._query.transport;\n    if (!~this.opts.transports.indexOf(transport)) {\n      debug('unknown transport \"%s\"', transport);\n      return fn(Server.errors.UNKNOWN_TRANSPORT, { transport });\n    }\n\n    // 'Origin' header check\n    const isOriginInvalid = checkInvalidHeaderChar(req.headers.origin);\n    if (isOriginInvalid) {\n      const origin = req.headers.origin;\n      req.headers.origin = null;\n      debug(\"origin header invalid\");\n      return fn(Server.errors.BAD_REQUEST, {\n        name: \"INVALID_ORIGIN\",\n        origin\n      });\n    }\n\n    // sid check\n    const sid = req._query.sid;\n    if (sid) {\n      if (!this.clients.hasOwnProperty(sid)) {\n        debug('unknown sid \"%s\"', sid);\n        return fn(Server.errors.UNKNOWN_SID, {\n          sid\n        });\n      }\n      const previousTransport = this.clients[sid].transport.name;\n      if (!upgrade && previousTransport !== transport) {\n        debug(\"bad request: unexpected transport without upgrade\");\n        return fn(Server.errors.BAD_REQUEST, {\n          name: \"TRANSPORT_MISMATCH\",\n          transport,\n          previousTransport\n        });\n      }\n    } else {\n      // handshake is GET only\n      if (\"GET\" !== req.method) {\n        return fn(Server.errors.BAD_HANDSHAKE_METHOD, {\n          method: req.method\n        });\n      }\n\n      if (!this.opts.allowRequest) return fn();\n\n      return this.opts.allowRequest(req, (message, success) => {\n        if (!success) {\n          return fn(Server.errors.FORBIDDEN, {\n            message\n          });\n        }\n        fn();\n      });\n    }\n\n    fn();\n  }\n\n  /**\n   * Prepares a request by processing the query string.\n   *\n   * @api private\n   */\n  prepare(req) {\n    // try to leverage pre-existing `req._query` (e.g: from connect)\n    if (!req._query) {\n      req._query = ~req.url.indexOf(\"?\") ? qs.parse(parse(req.url).query) : {};\n    }\n  }\n\n  /**\n   * Closes all clients.\n   *\n   * @api public\n   */\n  close() {\n    debug(\"closing all open clients\");\n    for (let i in this.clients) {\n      if (this.clients.hasOwnProperty(i)) {\n        this.clients[i].close(true);\n      }\n    }\n    if (this.ws) {\n      debug(\"closing webSocketServer\");\n      this.ws.close();\n      // don't delete this.ws because it can be used again if the http server starts listening again\n    }\n    return this;\n  }\n\n  /**\n   * Handles an Engine.IO HTTP request.\n   *\n   * @param {http.IncomingMessage} request\n   * @param {http.ServerResponse|http.OutgoingMessage} response\n   * @api public\n   */\n  handleRequest(req, res) {\n    debug('handling \"%s\" http request \"%s\"', req.method, req.url);\n    this.prepare(req);\n    req.res = res;\n\n    const callback = (errorCode, errorContext) => {\n      if (errorCode !== undefined) {\n        this.emit(\"connection_error\", {\n          req,\n          code: errorCode,\n          message: Server.errorMessages[errorCode],\n          context: errorContext\n        });\n        abortRequest(res, errorCode, errorContext);\n        return;\n      }\n\n      if (req._query.sid) {\n        debug(\"setting new request for existing client\");\n        this.clients[req._query.sid].transport.onRequest(req);\n      } else {\n        const closeConnection = (errorCode, errorContext) =>\n          abortRequest(res, errorCode, errorContext);\n        this.handshake(req._query.transport, req, closeConnection);\n      }\n    };\n\n    if (this.corsMiddleware) {\n      this.corsMiddleware.call(null, req, res, () => {\n        this.verify(req, false, callback);\n      });\n    } else {\n      this.verify(req, false, callback);\n    }\n  }\n\n  /**\n   * generate a socket id.\n   * Overwrite this method to generate your custom socket id\n   *\n   * @param {Object} request object\n   * @api public\n   */\n  generateId(req) {\n    return base64id.generateId();\n  }\n\n  /**\n   * Handshakes a new client.\n   *\n   * @param {String} transport name\n   * @param {Object} request object\n   * @param {Function} closeConnection\n   *\n   * @api private\n   */\n  async handshake(transportName, req, closeConnection) {\n    const protocol = req._query.EIO === \"4\" ? 4 : 3; // 3rd revision by default\n    if (protocol === 3 && !this.opts.allowEIO3) {\n      debug(\"unsupported protocol version\");\n      this.emit(\"connection_error\", {\n        req,\n        code: Server.errors.UNSUPPORTED_PROTOCOL_VERSION,\n        message:\n          Server.errorMessages[Server.errors.UNSUPPORTED_PROTOCOL_VERSION],\n        context: {\n          protocol\n        }\n      });\n      closeConnection(Server.errors.UNSUPPORTED_PROTOCOL_VERSION);\n      return;\n    }\n\n    let id;\n    try {\n      id = await this.generateId(req);\n    } catch (e) {\n      debug(\"error while generating an id\");\n      this.emit(\"connection_error\", {\n        req,\n        code: Server.errors.BAD_REQUEST,\n        message: Server.errorMessages[Server.errors.BAD_REQUEST],\n        context: {\n          name: \"ID_GENERATION_ERROR\",\n          error: e\n        }\n      });\n      closeConnection(Server.errors.BAD_REQUEST);\n      return;\n    }\n\n    debug('handshaking client \"%s\"', id);\n\n    try {\n      var transport = new transports[transportName](req);\n      if (\"polling\" === transportName) {\n        transport.maxHttpBufferSize = this.opts.maxHttpBufferSize;\n        transport.httpCompression = this.opts.httpCompression;\n      } else if (\"websocket\" === transportName) {\n        transport.perMessageDeflate = this.opts.perMessageDeflate;\n      }\n\n      if (req._query && req._query.b64) {\n        transport.supportsBinary = false;\n      } else {\n        transport.supportsBinary = true;\n      }\n    } catch (e) {\n      debug('error handshaking to transport \"%s\"', transportName);\n      this.emit(\"connection_error\", {\n        req,\n        code: Server.errors.BAD_REQUEST,\n        message: Server.errorMessages[Server.errors.BAD_REQUEST],\n        context: {\n          name: \"TRANSPORT_HANDSHAKE_ERROR\",\n          error: e\n        }\n      });\n      closeConnection(Server.errors.BAD_REQUEST);\n      return;\n    }\n    const socket = new Socket(id, this, transport, req, protocol);\n\n    transport.on(\"headers\", (headers, req) => {\n      const isInitialRequest = !req._query.sid;\n\n      if (isInitialRequest) {\n        if (this.opts.cookie) {\n          headers[\"Set-Cookie\"] = [\n            cookieMod.serialize(this.opts.cookie.name, id, this.opts.cookie)\n          ];\n        }\n        this.emit(\"initial_headers\", headers, req);\n      }\n      this.emit(\"headers\", headers, req);\n    });\n\n    transport.onRequest(req);\n\n    this.clients[id] = socket;\n    this.clientsCount++;\n\n    socket.once(\"close\", () => {\n      delete this.clients[id];\n      this.clientsCount--;\n    });\n\n    this.emit(\"connection\", socket);\n  }\n\n  /**\n   * Handles an Engine.IO HTTP Upgrade.\n   *\n   * @api public\n   */\n  handleUpgrade(req, socket, upgradeHead) {\n    this.prepare(req);\n\n    this.verify(req, true, (errorCode, errorContext) => {\n      if (errorCode) {\n        this.emit(\"connection_error\", {\n          req,\n          code: errorCode,\n          message: Server.errorMessages[errorCode],\n          context: errorContext\n        });\n        abortUpgrade(socket, errorCode, errorContext);\n        return;\n      }\n\n      const head = Buffer.from(upgradeHead); // eslint-disable-line node/no-deprecated-api\n      upgradeHead = null;\n\n      // delegate to ws\n      this.ws.handleUpgrade(req, socket, head, websocket => {\n        this.onWebSocket(req, socket, websocket);\n      });\n    });\n  }\n\n  /**\n   * Called upon a ws.io connection.\n   *\n   * @param {ws.Socket} websocket\n   * @api private\n   */\n  onWebSocket(req, socket, websocket) {\n    websocket.on(\"error\", onUpgradeError);\n\n    if (\n      transports[req._query.transport] !== undefined &&\n      !transports[req._query.transport].prototype.handlesUpgrades\n    ) {\n      debug(\"transport doesnt handle upgraded requests\");\n      websocket.close();\n      return;\n    }\n\n    // get client id\n    const id = req._query.sid;\n\n    // keep a reference to the ws.Socket\n    req.websocket = websocket;\n\n    if (id) {\n      const client = this.clients[id];\n      if (!client) {\n        debug(\"upgrade attempt for closed client\");\n        websocket.close();\n      } else if (client.upgrading) {\n        debug(\"transport has already been trying to upgrade\");\n        websocket.close();\n      } else if (client.upgraded) {\n        debug(\"transport had already been upgraded\");\n        websocket.close();\n      } else {\n        debug(\"upgrading existing transport\");\n\n        // transport error handling takes over\n        websocket.removeListener(\"error\", onUpgradeError);\n\n        const transport = new transports[req._query.transport](req);\n        if (req._query && req._query.b64) {\n          transport.supportsBinary = false;\n        } else {\n          transport.supportsBinary = true;\n        }\n        transport.perMessageDeflate = this.perMessageDeflate;\n        client.maybeUpgrade(transport);\n      }\n    } else {\n      // transport error handling takes over\n      websocket.removeListener(\"error\", onUpgradeError);\n\n      const closeConnection = (errorCode, errorContext) =>\n        abortUpgrade(socket, errorCode, errorContext);\n      this.handshake(req._query.transport, req, closeConnection);\n    }\n\n    function onUpgradeError() {\n      debug(\"websocket error before upgrade\");\n      // websocket.close() not needed\n    }\n  }\n\n  /**\n   * Captures upgrade requests for a http.Server.\n   *\n   * @param {http.Server} server\n   * @param {Object} options\n   * @api public\n   */\n  attach(server, options = {}) {\n    let path = (options.path || \"/engine.io\").replace(/\\/$/, \"\");\n\n    const destroyUpgradeTimeout = options.destroyUpgradeTimeout || 1000;\n\n    // normalize path\n    path += \"/\";\n\n    function check(req) {\n      return path === req.url.substr(0, path.length);\n    }\n\n    // cache and clean up listeners\n    const listeners = server.listeners(\"request\").slice(0);\n    server.removeAllListeners(\"request\");\n    server.on(\"close\", this.close.bind(this));\n    server.on(\"listening\", this.init.bind(this));\n\n    // add request handler\n    server.on(\"request\", (req, res) => {\n      if (check(req)) {\n        debug('intercepting request for path \"%s\"', path);\n        this.handleRequest(req, res);\n      } else {\n        let i = 0;\n        const l = listeners.length;\n        for (; i < l; i++) {\n          listeners[i].call(server, req, res);\n        }\n      }\n    });\n\n    if (~this.opts.transports.indexOf(\"websocket\")) {\n      server.on(\"upgrade\", (req, socket, head) => {\n        if (check(req)) {\n          this.handleUpgrade(req, socket, head);\n        } else if (false !== options.destroyUpgrade) {\n          // default node behavior is to disconnect when no handlers\n          // but by adding a handler, we prevent that\n          // and if no eio thing handles the upgrade\n          // then the socket needs to die!\n          setTimeout(function() {\n            if (socket.writable && socket.bytesWritten <= 0) {\n              return socket.end();\n            }\n          }, destroyUpgradeTimeout);\n        }\n      });\n    }\n  }\n}\n\n/**\n * Protocol errors mappings.\n */\n\nServer.errors = {\n  UNKNOWN_TRANSPORT: 0,\n  UNKNOWN_SID: 1,\n  BAD_HANDSHAKE_METHOD: 2,\n  BAD_REQUEST: 3,\n  FORBIDDEN: 4,\n  UNSUPPORTED_PROTOCOL_VERSION: 5\n};\n\nServer.errorMessages = {\n  0: \"Transport unknown\",\n  1: \"Session ID unknown\",\n  2: \"Bad handshake method\",\n  3: \"Bad request\",\n  4: \"Forbidden\",\n  5: \"Unsupported protocol version\"\n};\n\n/**\n * Close the HTTP long-polling request\n *\n * @param res - the response object\n * @param errorCode - the error code\n * @param errorContext - additional error context\n *\n * @api private\n */\n\nfunction abortRequest(res, errorCode, errorContext) {\n  const statusCode = errorCode === Server.errors.FORBIDDEN ? 403 : 400;\n  const message =\n    errorContext && errorContext.message\n      ? errorContext.message\n      : Server.errorMessages[errorCode];\n\n  res.writeHead(statusCode, { \"Content-Type\": \"application/json\" });\n  res.end(\n    JSON.stringify({\n      code: errorCode,\n      message\n    })\n  );\n}\n\n/**\n * Close the WebSocket connection\n *\n * @param {net.Socket} socket\n * @param {string} errorCode - the error code\n * @param {object} errorContext - additional error context\n *\n * @api private\n */\n\nfunction abortUpgrade(socket, errorCode, errorContext = {}) {\n  socket.on(\"error\", () => {\n    debug(\"ignoring error from closed connection\");\n  });\n  if (socket.writable) {\n    const message = errorContext.message || Server.errorMessages[errorCode];\n    const length = Buffer.byteLength(message);\n    socket.write(\n      \"HTTP/1.1 400 Bad Request\\r\\n\" +\n        \"Connection: close\\r\\n\" +\n        \"Content-type: text/html\\r\\n\" +\n        \"Content-Length: \" +\n        length +\n        \"\\r\\n\" +\n        \"\\r\\n\" +\n        message\n    );\n  }\n  socket.destroy();\n}\n\nmodule.exports = Server;\n\n/* eslint-disable */\n\n/**\n * From https://github.com/nodejs/node/blob/v8.4.0/lib/_http_common.js#L303-L354\n *\n * True if val contains an invalid field-vchar\n *  field-value    = *( field-content / obs-fold )\n *  field-content  = field-vchar [ 1*( SP / HTAB ) field-vchar ]\n *  field-vchar    = VCHAR / obs-text\n *\n * checkInvalidHeaderChar() is currently designed to be inlinable by v8,\n * so take care when making changes to the implementation so that the source\n * code size does not exceed v8's default max_inlined_source_size setting.\n **/\n// prettier-ignore\nconst validHdrChars = [\n  0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, // 0 - 15\n  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, // 16 - 31\n  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, // 32 - 47\n  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, // 48 - 63\n  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, // 64 - 79\n  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, // 80 - 95\n  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, // 96 - 111\n  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, // 112 - 127\n  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, // 128 ...\n  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,\n  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,\n  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,\n  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,\n  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,\n  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,\n  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1  // ... 255\n]\n\nfunction checkInvalidHeaderChar(val) {\n  val += \"\";\n  if (val.length < 1) return false;\n  if (!validHdrChars[val.charCodeAt(0)]) {\n    debug('invalid header, index 0, char \"%s\"', val.charCodeAt(0));\n    return true;\n  }\n  if (val.length < 2) return false;\n  if (!validHdrChars[val.charCodeAt(1)]) {\n    debug('invalid header, index 1, char \"%s\"', val.charCodeAt(1));\n    return true;\n  }\n  if (val.length < 3) return false;\n  if (!validHdrChars[val.charCodeAt(2)]) {\n    debug('invalid header, index 2, char \"%s\"', val.charCodeAt(2));\n    return true;\n  }\n  if (val.length < 4) return false;\n  if (!validHdrChars[val.charCodeAt(3)]) {\n    debug('invalid header, index 3, char \"%s\"', val.charCodeAt(3));\n    return true;\n  }\n  for (let i = 4; i < val.length; ++i) {\n    if (!validHdrChars[val.charCodeAt(i)]) {\n      debug('invalid header, index \"%i\", char \"%s\"', i, val.charCodeAt(i));\n      return true;\n    }\n  }\n  return false;\n}\n"]},"metadata":{},"sourceType":"script"}